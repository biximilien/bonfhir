import { readFile, writeFile } from "fs/promises";
import hb from "handlebars";
import handlebarsHelpers from "handlebars-helpers";
import Listr, { ListrTask } from "listr";
import _ from "lodash";
import { join, join as pathJoin, parse as pathParse } from "node:path";
import path from "path";
import { Context } from "./context";
import { elementImmediatePath } from "./helpers/elementImmediatePath";
import { fhirPath } from "./helpers/fhirPath";
import { inFn } from "./helpers/in";
import { notIn } from "./helpers/notIn";
import { buildReadLines } from "./helpers/readLines";
import { recursiveFlatten } from "./helpers/recursiveFlatten";
import { replaceNewLines } from "./helpers/replaceNewLines";
import { safeNameAsVar } from "./helpers/safeNameAsVar";
import { valueSetExpansions } from "./helpers/valueSetExpansions";
import { buildWriteFiles } from "./helpers/writeFiles";

/**
 * For each of the template files, execute a subtask to render the template by passing
 * the current context.
 * Injects custom helpers as well:
 *  - all helpers from [handlebars-helpers](https://assemble.io/helpers/)
 *  - `startCase` from [lodash](https://lodash.com/docs/4.17.15#startCase)
 *  - `uniq` from [lodash](https://lodash.com/docs/4.17.15#uniq)
 *  - `uniqBy` from [lodash](https://lodash.com/docs/4.17.15#uniqBy)
 *  - helpers from the `helpers` directory
 */
export const ProcessTemplatesTask: ListrTask<Context> = {
  title: "Process templates",
  task: async (ctx) => {
    return new Listr<Context>(ctx.templates.map(CreateTemplateProcessTask));
  },
};

function CreateTemplateProcessTask(templatePath: string): ListrTask<Context> {
  const templateParsedPath = pathParse(templatePath);
  return {
    title: templateParsedPath.name,
    task: async (ctx) => {
      const compiledTemplate = hb.compile(
        await readFile(templatePath, "utf8"),
        {
          noEscape: true,
          preventIndent: true,
        }
      );

      let result = compiledTemplate(ctx, {
        helpers: {
          ...handlebarsHelpers(),
          startCase: _.startCase,
          uniq: _.uniq,
          uniqBy: _.uniqBy,
          elementImmediatePath,
          fhirPath,
          in: inFn,
          notIn,
          readLines: buildReadLines(templateParsedPath.dir),
          recursiveFlatten,
          replaceNewLines,
          safeNameAsVar,
          valueSetExpansions,
          writeFiles: buildWriteFiles(ctx, templateParsedPath.dir),
          ...(ctx.helpers || {}),
        },
      });

      if (result.trim()) {
        const targetFile = pathJoin(
          templateParsedPath.dir,
          templateParsedPath.name
        );

        result = await PushAutogeneratedNote(templatePath, result);

        await writeFile(targetFile, result, { encoding: "utf8" });

        ctx.writtenFiles.push(targetFile);
      }
    },
  };
}

async function PushAutogeneratedNote(
  templatePath: string,
  result: string
): Promise<string> {
  const __dirname = path.resolve();
  const noteTemplatePath = join(
    __dirname,
    "src",
    "commands",
    "run",
    "autogenerated-note.hbs"
  );

  const displayedPath = templatePath.split(`${path.resolve("../..")}/`)[1];
  const compiledAutoGeneratedNoteTemplate = hb.compile(
    await readFile(noteTemplatePath, "utf8"),
    {
      noEscape: true,
      preventIndent: true,
    }
  );

  const note = compiledAutoGeneratedNoteTemplate(null, {
    helpers: {
      templatePath: () => displayedPath,
    },
  });

  return note + result;
}
