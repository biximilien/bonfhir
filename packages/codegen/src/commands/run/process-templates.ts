import { readFile, writeFile } from "fs/promises";
import hb from "handlebars";
import handlebarsHelpers from "handlebars-helpers";
import Listr, { ListrTask } from "listr";
import { join as pathJoin, parse as pathParse } from "node:path";
import { pushAutogeneratedNote } from "./autogenerated-note";
import { Context } from "./context";
import { elementImmediatePath } from "./helpers/elementImmediatePath";
import { fhirPath } from "./helpers/fhirPath";
import { inFn } from "./helpers/in";
import { notIn } from "./helpers/notIn";
import { buildReadLines } from "./helpers/readLines";
import { recursiveFlatten } from "./helpers/recursiveFlatten";
import { replaceNewLines } from "./helpers/replaceNewLines";
import { safeNameAsVar } from "./helpers/safeNameAsVar";
import { startCase } from "./helpers/startCase";
import { uniq } from "./helpers/uniq";
import { uniqBy } from "./helpers/uniqBy";
import { valueSetExpansions } from "./helpers/valueSetExpansions";
import { buildWriteFiles } from "./helpers/writeFiles";

/**
 * For each of the template files, execute a subtask to render the template by passing
 * the current context.
 * Injects custom helpers as well:
 *  - all helpers from [handlebars-helpers](https://assemble.io/helpers/)
 *  - helpers from the `helpers` directory
 */
export const ProcessTemplatesTask: ListrTask<Context> = {
  title: "Process templates",
  task: async (ctx) => {
    return new Listr<Context>(ctx.templates.map(CreateTemplateProcessTask));
  },
};

function CreateTemplateProcessTask(templatePath: string): ListrTask<Context> {
  const templateParsedPath = pathParse(templatePath);
  return {
    title: templateParsedPath.name,
    task: async (ctx) => {
      const compiledTemplate = hb.compile(
        await readFile(templatePath, "utf8"),
        {
          noEscape: true,
          preventIndent: true,
        }
      );

      let result = compiledTemplate(ctx, {
        helpers: {
          ...handlebarsHelpers(),
          startCase,
          uniq,
          uniqBy,
          elementImmediatePath,
          fhirPath,
          in: inFn,
          notIn,
          readLines: buildReadLines(templateParsedPath.dir),
          recursiveFlatten,
          replaceNewLines,
          safeNameAsVar,
          valueSetExpansions,
          writeFiles: buildWriteFiles(ctx, templateParsedPath.dir),
          ...(ctx.helpers || {}),
        },
      });

      if (result.trim()) {
        const targetFile = pathJoin(
          templateParsedPath.dir,
          templateParsedPath.name
        );

        result = pushAutogeneratedNote(templatePath, result, ctx.config.header);

        await writeFile(targetFile, result, { encoding: "utf8" });

        ctx.writtenFiles.push(targetFile);
      }
    },
  };
}
